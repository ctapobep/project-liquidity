\subsection{Heavyweigths}
Some software is just created to eat too much, there is plenty of code, hell a lot of \sout{unneeded and overloaded} functionality and everything is packed into a single app. There is quite an obvious alternative here - creating SOA architecture. The idea is simple and well-known - splitting functionality into services that can communicate via different protocols. And it doesn't even matter whether it's SOAP, REST, JMS or even Protobuf. It's hard to exaggerate when it comes to benefits of such architecture:
\begin{itemize}
  \item Several teams can work on different code bases without stepping on each other toes. For a dozen of people it's much harder to work on a single SCM repository than on two separate repos, they start to introduce conflicts, work on branches and thus introducing merges and late integration with main codebase which itself results in more expenses because of late-discovered issues.
  \item Releasing becomes more straightforward. Let's say the software is monolith. What if one part of team is ready to release and another part is still stabalizing? They both have to wait. This postpones releases and raises conflicts between teams. Even worse - what if both teams released, but one of them have to rollback? The more changes you introduce to a single release, the more you might need to rollback. Such problems disappear if codebase is split.
  \item The area of knowledge becomes smaller when it comes to services. A new joiner has to know only a limited part of business: it's easier if you can start to work on a small piece. If you need more - you're welcome to learn another system, but this doesn't prevent you from writing code in the first place!
  \item Services can go with different speed. Because they communicate via protocols, it's not that crucial for them to keep up with each other, one part can go further and implement some functionality that depends on another service. They do this using mocking, after that they have a stabalized API which can be provided to the second service to implement.
  \item Services can be implemented using different platforms. For instance a web part can use Ruby on Rails while backend can still be Java. From one perspective people can't rotate that easy which might be a problem, but there is another interesting side developers don't usually think about - job market. First of all there might be a lack of professionals for that particular platform and PM (or customer) may want to hire specialists from different group of developers. Second, there is an easier possibility to offshore the work for the sake of saving money.
  \item Refactoring and rewriting becomes easier. Because services are smaller, you can refactor one of them and thus bound the scope of possible bugs to a single service.
  \item And finally you'll be able to start a small app on local machine which is our aim. You'll need some mocking though, we'll discuss this later in the book.
\end{itemize}
There is another side of the coin - you have to write integration tests, manage many artifacts isntead of a single one, but in a long run it will be easier. Just don't start splitting from the beginning, first project should grow enough in order to be split, otherwise there will be overhead of managing projects.

