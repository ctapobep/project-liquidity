\subsection{Solely distributed systems}
When it comes to heterogeneous systems, we write mocks to get rid of dependencies on surroundings. In case of homogeneous nodes we have a single app that's just spread across several machines. The problem that arises from time to time - it might be impossible to use this software on a single node. These are often projects that benefit from distributed cache or databases, or use compute/data grids. The problem of such projects it that even though they might be useful and have their niche, they are still pretty complicated to kick off which contradicts our objective - to start up quickly. Let's go over some recipes.

\textbf{Start from a single-node project.} I once participated in a project that from its beginning started to build a distributed system that was going to use NoSQL database along with SQL one to increase potential capacity of the project. Did you notice word "potential"? It's there because a lot of projects and business ideas crash before getting to the final state. Others, when they reach it, appear to be less popular than it was anticipated. And only some of them gain popularity. Thus, keep it simple from the beginning and first get some results. If you get problems with performance - that's a good sign, someone uses you.

This has a side effect. If you start from a single-node, then you build a system that can be started locally without overhead. Afterwards, even though you added ability to work on multiple nodes, you should always support single-node mode. If it is inefficient performance-wise, then single- and multi-node modes can use different code to start their jobs! Such different code of course should be minimized so that you don't end up supporting two systems, plus when you write your main business code, it should not care whether it's a distributed environment or not, it should work in both cases.
