\documentclass[11pt,a4paper,oneside]{article}
\usepackage{ulem}
\begin{document}
\section{Local Deployment}
Imagine yourself joining the project, what's the first thing you'd like to have? Right - the project up and running. It's crucial for people to see the software in action to understand it, and it's not enough to see it in production or on some shared environment. Any other environment is more restrictive than local one: you don't have permissions to see everything like admin panel, or you can damage the environment by pressing a red button - and you don't want to damange anything on the first day of the project, don't you?

Why this is so important? Remember our aim is to get people fully started in 2 weeks - and that's what impossible if you can't run the project easily. 

First of all because you need to understand the infrastructure: what databases are used, what protocols are there to communicate between different systems or different nodes. 

Second, you need to understand the workflow: different kind of requests can be processed differently, and this also may be dependant on current state. In order to understand the workflow developer has to debug the system - this is the only way he can feel it. Even if you have some special frameworks to build your flows like Apache Camel, Spring Integration or even Disruptor which can help you with creating and following routes of the workflow, they still can be pretty combersome and complicated. I've seen systems which were using such frameworks, but yet they were that big and splitted for the sake of DRY (don't repeat yourself principle), that it took efforts of several people who spent days to read just couple of routes. And one of the reasons - we couldn't run that system locally. So we had to guess. That's not a situation you want to appear when it comes to new stuff. You can guess and be creative when you understand things already, but not on the first days on new position.

Third thing - business domain. It's important for developer to understand the area he works with and how this or that action changes that domain. If you have a database and you're free to do any business action, you can see the results right away. If you know the impact of clicking on that button, you can figure out what that freaking term means in scope of data changes. Plus you can debug it and thus you have some means already to understand that business you're going to work with. This might be harder in a very asynchroneous architecture because it might be nearly impossible to debug concurrent code, but you still have more tools than people who can't afford local environment.

That's why you need the app started locally. Now we have a clear understanding of our first objective, let's get acquainted with problems that may stop us getting a perfect project.

\section{Obsticles to have local environment}

There are probably some people thinking that it's not always possible, and these people might be right - not all the projects are built the way they can be started on development machine. But what people are usually missing here is that these projects and this software is created by us, and it's our responsibility to make them as liquid as possible. Let's see what can be the reasons and how we can overcome these obsticles.

Some software might require 16G of RAM to get started with 8 cores, and I don't think that all development machines in your company have that horsepower. 

Another case is - some projects are built the way it shouldn't be possible to run it on a single node. They are built solely for distributed usage, there is no logical use case when you'd need to run it on single miserable machine.

Additionally your system might need to collaborate with others, it might get input from them or produce output. In this case you might need to deploy the whole ecosystem of your organization which surely is not an option. Often, there are hundreds of systems connected to each other.

Last issue I can think of - is the complexity of environment. There might be some big cool database like Oracle which you don't want to install locally for example because it's hard to install on your particular OS or you can't do this because of licensing issues; or messaging-oriented firmware like Solace which seems to be very fast, but it requires special hardware; or Cassandra which can't be deployed on a single node anyway. 

Let's go step by step and try to figure out how to cope with all these issues.
\subsection{Heavyweigths}
Some software is just created to eat too much, there is plenty of code, hell a lot of \sout{unneeded and overloaded} functionality and everything is packed into a single app. There is quite an obvious alternative here - creating SOA architecture. The idea is simple and well-known - splitting functionality into services that can communicate via different protocols. And it doesn't even matter whether it's SOAP, REST, JMS or even Protobuf. It's hard to exaggerate when it comes to benefits of such architecture:
\begin{itemize}
  \item Several teams can work on different code bases without stepping on each other toes. For a dozen of people it's much harder to work on a single SCM repository than on two separate repos, they start to introduce conflicts, work on branches and thus introducing merges and late integration with main codebase which itself results in more expenses because of late-discovered issues.
  \item Releasing becomes more straightforward. Let's say the software is monolith. What if one part of team is ready to release and another part is still stabalizing? They both have to wait. This postpones releases and raises conflicts between teams. Even worse - what if both teams released, but one of them have to rollback? The more changes you introduce to a single release, the more you might need to rollback. Such problems disappear if codebase is split.
  \item The area of knowledge becomes smaller when it comes to services. A new joiner has to know only a limited part of business: it's easier if you can start to work on a small piece. If you need more - you're welcome to learn another system, but this doesn't prevent you from writing code in the first place!
  \item Services can go with different speed. Because they communicate via protocols, it's not that crucial for them to keep up with each other, one part can go further and implement some functionality that depends on another service. They do this using mocking, after that they have a stabalized API which can be provided to the second service to implement.
  \item Services can be implemented using different platforms. For instance a web part can use Ruby on Rails while backend can still be Java. From one perspective people can't rotate that easy which might be a problem, but there is another interesting side developers don't usually think about - job market. First of all there might be a lack of professionals for that particular platform and PM (or customer) may want to hire specialists from different group of developers. Second, there is an easier possibility to offshore the work for the sake of saving money.
  \item Refactoring and rewriting becomes easier. Because services are smaller, you can refactor one of them and thus bound the scope of possible bugs to a single service.
\end{itemize}

\end{document}
